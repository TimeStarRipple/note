# java线程

## 背景

几乎所有的操作系统，都能支持运行多个任务，一个任务通常就是一个程序，每个运行中的程序都是一个进程  
进程：进程是处于运行过程中程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的独立单元。

进程的特征：

* 独立性：进程是系统中独立的实体，拥有自己独立的资源，没有经过进程本身的允许，其他用户进程是无法访问该进程的资源
* 动态性：进程是一个正在系统中活动的指令集合，具有时间的概念
* 并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响

java采用抢占式多任务操作策略

## 定义

线程：轻量级进程，是进程的执行单元，一个进程一定包含一个线程，并且可以包含多个线程，线程有自己的堆栈，程序计数器，但不拥有系统资源，它与父进程的其他线程共享该进程所有资源

## 优势

* 共享内存：进程间无法共享内存，线程可以
* 创建代价小：创建进程的代价大，线程比较小
* java底层内置了多线程支持，不是单纯的底层操作系统，简化了java的多线程编程

## 线程的创建和启动

### 继承Thread类创建线程类：（无法使线程共享实例变量）

1. 定义Thread类的子类，并重写该类的run（）方法，该run（）方法的方法体就代表了线程需要执行的任务
2. 创建Thread子类实例
3. 调用线程对象的start方法启动线程

### 实现Runnable接口创建线程类：（可以使线程共享实例变量）

1. 定义Runnable接口实现类，并重写该接口的run（）方法，作为线程执行体
2. 创建Runnable实现类实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象

### 使用Callable和Future创建线程：（除了共享还能返回值以及抛出异常）

1. 创建Callable接口的实现类，并实现call方法，将call方法将作为线程执行体，还有返回值，再创建Callable实现类的实例
2. 使用FutureTask类来包装Callable对象，该对象封装了该Callable对象的call（）方法的返回值
3. 使用FutureTask对象来作为Thread对象的target创建并启动新线程
4. 使用FutureTask对象的get（）方法来获取子线程执行结束后的返回值

### 不同线程创建方法的优劣

采用实现Runnable，Callable方式创建的优劣：

* 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类
* 在这种方式下，多个线程可以共享同一个target对象，可以使用多个相同线程来处理一份资源
* 缺点是，编程复杂，如果要访问当前线程，要采用Thread.currentThread（）

采用继承Thread类的方式创建多线程的优劣：

* 劣势是，继承了Thread就不能继承其他类了，以及无法共享数据
* 优势是，编写简单，如果需要访问当前线程，直接使用this

但是一般使用线程都是希望能同时操作一个数据，所以都是用前者进行多线程操作

## 线程状态

![](/java/images/java-thread-1.jpg)

1、新建状态（New）：新创建了一个线程对象。

2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start\(\)方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。

4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

（一）、等待阻塞：运行的线程执行wait\(\)方法，JVM会把该线程放入等待池中。

（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。

（三）、其他阻塞：运行的线程执行sleep\(\)或join\(\)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep\(\)状态超时、join\(\)等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5、死亡状态（Dead）：线程执行完了或者因异常退出了run\(\)方法，该线程结束生命周期。

## 线程方法

* sleep\(\)：线程进行休眠，进入阻塞状态
* join\(\)：当前线程会等待使用这个方法的线程结束后进入就绪状态，等待执行
* wait\(\)：进入等待池，等待被唤醒。
* setPriority\(\)：设置优先级，默认是6，范围1-10
* yield\(\)：放弃占用cpu，变成就绪状态

## 线程同步

1.同步代码块

加锁，修改，释放锁

```java
synchronized（obj）{
    //同步代码块
}
```

2.同步方法

## 线程通信

## 线程安全

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。  
或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。  
线程安全问题都是由全局变量及静态变量引起的。  
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

