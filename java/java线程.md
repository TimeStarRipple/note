# java线程

## 背景

几乎所有的操作系统，都能支持运行多个任务，一个任务通常就是一个程序，每个运行中的程序都是一个进程  
进程：进程是处于运行过程中程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的独立单元。

进程的特征：

* 独立性：进程是系统中独立的实体，拥有自己独立的资源，没有经过进程本身的允许，其他用户进程是无法访问该进程的资源
* 动态性：进程是一个正在系统中活动的指令集合，具有时间的概念
* 并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响

java采用抢占式多任务操作策略

## 定义

线程：轻量级进程，是进程的执行单元，一个进程一定包含一个线程，并且可以包含多个线程，线程有自己的堆栈，程序计数器，但不拥有系统资源，它与父进程的其他线程共享该进程所有资源

## 优势

* 共享内存：进程间无法共享内存，线程可以
* 创建代价小：创建进程的代价大，线程比较小
* java底层内置了多线程支持，不是单纯的底层操作系统，简化了java的多线程编程

## 线程的创建和启动

### 继承Thread类创建线程类：（无法使线程共享实例变量）

1. 定义Thread类的子类，并重写该类的run（）方法，该run（）方法的方法体就代表了线程需要执行的任务
2. 创建Thread子类实例
3. 调用线程对象的start方法启动线程

### 实现Runnable接口创建线程类：（可以使线程共享实例变量）

1. 定义Runnable接口实现类，并重写该接口的run（）方法，作为线程执行体
2. 创建Runnable实现类实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象

### 使用Callable和Future创建线程：（除了共享还能返回值以及抛出异常）

1. 创建Callable接口的实现类，并实现call方法，将call方法将作为线程执行体，还有返回值，再创建Callable实现类的实例
2. 使用FutureTask类来包装Callable对象，该对象封装了该Callable对象的call（）方法的返回值
3. 使用FutureTask对象来作为Thread对象的target创建并启动新线程
4. 使用FutureTask对象的get（）方法来获取子线程执行结束后的返回值

### 不同线程创建方法的优劣

采用实现Runnable，Callable方式创建的优劣：

* 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类
* 在这种方式下，多个线程可以共享同一个target对象，可以使用多个相同线程来处理一份资源
* 缺点是，编程复杂，如果要访问当前线程，要采用Thread.currentThread（）

采用继承Thread类的方式创建多线程的优劣：

* 劣势是，继承了Thread就不能继承其他类了，以及无法共享数据
* 优势是，编写简单，如果需要访问当前线程，直接使用this

但是一般使用线程都是希望能同时操作一个数据，所以都是用前者进行多线程操作

## 线程状态

![](/java/images/java-thread-1.jpg)

1、新建状态（New）：新创建了一个线程对象。

2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start\(\)方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。

3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。

4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

（一）、等待阻塞：运行的线程执行wait\(\)方法，JVM会把该线程放入等待池中。

（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。

（三）、其他阻塞：运行的线程执行sleep\(\)或join\(\)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep\(\)状态超时、join\(\)等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5、死亡状态（Dead）：线程执行完了或者因异常退出了run\(\)方法，该线程结束生命周期。

## 线程方法

* sleep\(\)：线程进行休眠，进入阻塞状态
* join\(\)：当前线程会等待使用这个方法的线程结束后进入就绪状态，等待执行
* wait\(\)：进入等待池，等待被唤醒。
* setPriority\(\)：设置优先级，默认是6，范围1-10
* yield\(\)：放弃占用cpu，变成就绪状态

## 线程同步

### 1.同步代码块

加锁，修改，释放锁

```java
synchronized（obj）{
    //同步代码块
}
```

### 2.同步方法

```java
public synchronized void draw（double drawAmount）{
    //同步方法
}
```

synchronized 可以修饰代码块，方法，不能修饰构造器，成员变量

### 3.同步锁

```java
ReentrantLock lock = new ReentrantLock()
lock.lock()
//方法体
lock.unlock()
```

### 释放锁的条件

* 同步程序正常结束，或者遇到return，break等
* 异常退出
* 遇到wait（）方法

### 不会释放锁的情况

* 同步程序中，调用Thread.sleep\(\)，Thread.yield\(\)方法来暂停程序，不会释放
* 其他线程调用了该线程的suspend\(\)方法将线程挂起，不会释放，容易死锁，需要线程调用该线程的resume\(\)方法才可以

### 注：死锁

两个线程相互等待对方释放各自占用的资源，会造成死锁

## 线程通信

### 采用wait\(\)，notify\(\)，和notifyAll\(\)进行通信

要求使用synchronized关键字来保持同步，notify\(\)是随机选一个唤醒

### 使用Condition控制线程通信

要求使用lock方法来保持同步

```
private final Lock lock = new ReentrantLock();
private final Condition cond = lock.newCondition();
...
//加锁
lock.lock()
...
//阻塞
cond.await();
...
//唤醒
cond.signalAll();
...
lock.unlock()
```

### 使用阻塞队列（BlockingQueue）控制线程通信

BlockingQueue是Queue的子接口，不是作为容器，而是实现线程同步，当生产者线程向队列里面放入元素时，如果队列满了，则线程阻塞，当消费者线程试图从队列里面取出数据，如果队列空了，那么线程堵塞，`put()`方法添加，`take()`拿到

## 线程组

用来分类管理线程，还可以对没有被处理的线程异常进行处理

## 线程池

系统启用一个新线程的成本比较高，因为他涉及到与操作系统的交互。使用线程池可以提高很多性能

* 减少线程创建的成本
* 控制当前系统中并发线程的数量，线程池里有多少就只能用多少

采用静态工厂的方式创建线程池

#### ForkJoinPool\(java7\)

用于将大任务分解成多个小任务，然后计算完成后合并

## 线程安全

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。  
或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。  
线程安全问题都是由全局变量及静态变量引起的。  
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

### 工具类

#### ThreadLocal：

Thread Local Variable（线程局部变量），为每一个使用该变量的值都提供一个副本

```java
ThreadLocal<String> name = new ThreadLocal<>();
//..
public void run(){
  //对name的使用
}
```

主要用于隔离多个线程之间的存储空间，但如果线程间需要共享资源，就要使用同步，如果要隔离线程间的空间，就用ThreadLocal

计算机对于频繁使用的数据，计算机会进行缓存，使用`volatile`，可以直接读内存不读取缓存，保证数据是最新的

#### 包装线程不安全的集合

使用Collections工具类的同步方法构建集合，可以使得结合变安全。

```
<T> Collection<T> synchronizedCollection(Collection<T> c)
static <T> List<T> synchronizedList(List<T> list)
...
```

#### 线程安全的集合类

从java5开始，在java.util.concurrent包下提供了大量支持高效并发访问的集合接口和实现类

* 以Concurrent开头的集合类，如ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue和ConcurrentLinkedDeque
* 以CopyOnWrite开头的集合类，如CopyOnWriteArrayList、CopyOnWriteArraySet

**Concurrent开头集合类：**

锁定写操作，允许并发写入，不锁定读操作，默认支持16个并发

**CopyOnWrite开头的集合类：**

底层采用复制的方式，在写入操作时，复制数据到新的空间中去操作，所以是线程安全的。

但是由于写操作要经常复制，效率低

读操作没有锁，很快，适用于读操作远大于写操作的情况

