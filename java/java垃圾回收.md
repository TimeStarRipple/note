# java垃圾回收（GC）

新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。

两个最基本的java回收算法：复制算法和标记清理算法  
复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法  
标记清理：一块区域，标记要回收的对象，然后回收，一定会出现碎片，那么引出  
标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象

## 作用

* 回收被无用对象占用的内存空间
* 使该空间可被程序再次使用

## 发生时机

* CPU空闲（垃圾回收线程优先级最低）
* 内存不够

## 特点

* 垃圾回收机制的工作目标回收无用对象的内存空间，位于堆内存
* 为了更快让垃圾回收机制回收那些不用的内存，可以将引用变量设置为null
* 垃圾回收的精确性主要包括两个方面：一是垃圾回收机制能精确的标记活着的对象，二是垃圾回收期能精确的定位对象间的引用关系
* 现在JVM有很多垃圾回收的实现，每种算法不大一样，有的当垃圾回收开始时就停止程序运行，有的即使开始了也允许程序运行，还有就是同一时间允许多线程运行
* 垃圾回收之前会运行对象的`finalize()`方法，该方法可能使该对象重新复活（让一个引用变量重新引用它），从而导致垃圾回收取消

## GC类型

### Minor GC {#articleHeader0}

从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。

### **Major GC**

是清理永久代。

### **Full GC**

清理整个堆空间—包括年轻代和永久代。

## 对象状态

![](/java/images/gc-1.png)

* 可达状态：有一个以上的对象引用它
* 可恢复状态：没有对象再引用它，然后会调用`finalize()`方法，如果重新获得了，那就变成可达状态
* 不可达状态：可恢复状态调用finalize\(\)方法，也没有恢复引用，那就变成不可达状态

## 引用级别

* 强引用：StrongReference正常创建对象的引用
* 软引用：SoftReference垃圾回收可能会回收该引用内存，内存够就不会
* 弱引用：WeakReference比软引用程度低，不管内存够不够，垃圾回收都会回收该内存
* 虚引用：PhantomReference有和没有引用没有区别，主要用户跟踪垃圾回收的状态，不能单独使用，要和引用队列一起使用

## 版本信息

* java7：2011年发布的java7提供了GI垃圾回收器代替原有的GMS
* java8：2014年发布的java8删除了HotSpot JVM中的永生代内存（PerGen），改用本地内存来存储类的元数据信息，称之为元空间，也就是说后面再也没有OutOfMemoryError：PermGen



