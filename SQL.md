# SQL

## 数据库

遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小

### 名词解释

* 侯选关键字：又叫侯选码，惟一标识一行数据，其真子集不能是侯选关键字，一个表可以存在多个侯选关键字，如用户表的username，userid

* 主关键字：又叫主键，主码，被选中的用来区分其它行的侯选关键字，一个表只有一个主关键字

* 部分依赖：\(A,B\)-&gt;C,D,如A-&gt;C,则C部分依赖A

* 传递依赖：A-&gt;B-&gt;C,则C传递依赖A

### SQL语句

```
select * from departments where department_id = 1

insert into departments (department_id, department_name ) values (30, 'Purchasing' );

delete from departments where department_name = 'Finance';

update employees set department_id = 70 where employee_id = 113;
```

### 连接

1**、自然连接（natural join）**

通过MySql自己的判断完成连接过程，不需要指定连接条件。mysql自己使用连接的几张表中相同字符，作为连接条件

```
select * from one natural join two
```

2**、内联接（inner join）**

（典型的联接运算，使用像 =  或 &lt; &gt;之类的比较运算符）。包括相等联接和自然联接。

内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。

```
select   a.*,b.*   from   a   inner   join   b     on   a.id=b.parent_id
```

3**、外联接。（outer join）**

外联接可以是左向外联接、右向外联接或完整外部联接。

在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：

1）LEFT  JOIN或LEFT OUTER JOIN

左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。

```
select   a.*,b.*   from   a   left   join   b     on   a.id=b.parent_id
```

2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN

右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。

```
select   a.*,b.*   from   a   right   join   b     on   a.id=b.parent_id      
```

3）FULL  JOIN 或 FULL OUTER JOIN（mysql不支持）

完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。

```
select   a.*,b.*   from   a   full   join   b     on   a.id=b.parent_id   
```

4**、交叉联接 （cross join）**

交叉联接使用左表中的所有行，左表中的每一行与右表中的所有行组合。结果行数是两者行数乘积，交叉联接也称作笛卡尔积。以下有两种方式使用：一种隐式不使用关键字，另一种使用关键字，结果相同。

```
select O.ID, O.ORDER_NUMBER, C.ID, C.NAME from ORDERS O , CUSTOMERS C where O.ID=1;
select O.ID,O.ORDER_NUMBER,C.ID, C.NAME from ORDERS O cross join CUSTOMERS C where O.ID=1;
```

### 连接效率

1. 一般使用内连接，外链接效率低一些，交叉连接最低
2. 可以在连接字段上面加索引

### 范式类别

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式\(4NF）和第五范式（5NF，又称完美范式）。

1.第一范式：**数据库的字段是单一属性，不可再分（**保证列不重复**）**

强调的是列的原子性，即列不能够再分成其他几列，并且列不能重复。以此保证列不重复。

2.第二范式：**任何非关键字段不能部分依赖任一侯选关键字（**消除部分子函数依赖**）**

首先满足1NF，如果主键是单一的键就满足2NF，如果是有多列组成，那么除了主键以外的所有列，必须完全依赖于主键，而不能只依赖于主键的一部分。也就是说其他列只能由主键确定自己的值，不能由一部分列确定自己的值。

3.第三范式：**任何非关键字段不能传递依赖任一侯选关键字（**消除部分传递依赖**）**

首先满足2NF，非关键字不依赖于任何其他非关键字

4.BC范式：**任何字段都不能传递依赖任一侯选关键字（**消除所有传递依赖**）**

首先满足3NF，候选关键字不能依赖于非候选关键字，候选关键字之间不能相互依赖

5.第四范式：要求把同一表内的多对多关系删除。

6.第五范式：从最终结构重新建立原始结构。

### 开发注意

1. 使用范式会造成更多的数据库连接，而数据库连接会带来一部分的性能损失
2. 并不是数据库范式越高越好
3. 有时会在数据冗余与范式之间做出权衡，在实际的数据库开发过程中，往往会允许一部分的数据冗余来减少数据库连接。

## 事务

### 事务的特性

事务的四大特性（ACID）

1.原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2.一致性（Consistency）

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3.隔离性（Isolation）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

4.持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

### 事务的隔离级别

1. Read uncommitted \(读未提交\)：最低级别，任何情况都无法保证。其他事务可以读取该事务没有提交的数据。

2. Read committed \(读已提交\)：可避免脏读的发生。被事务操作的数据只有当事务提交后，才可以被其他事务所读取到。

3. Repeatable read \(可重复读\)：可避免脏读、不可重复读的发生。当一个事务在读取数据时，不允许其他事务对这些数据进行操作。

4. Serializable \(串行化\)：可避免脏读、不可重复读、幻读的发生。在同一时刻只能有一个事务在执行，意味着另一个事务只有在当前事务执行结束后才可以执行

### 不同隔离级别事务的问题

1. 脏读：读取到当前还没有提交的数据操作，通俗理解为读取到不干净的数据，本来不是这个样子。当事务回滚后，真实数据又和读取到的数据不符合。采用读已提交的隔离级别可以防止这种情况。
2. 不可重复读：同一事务两次读取到的值不一样。指的是该事务第一次读取时，数据是这样子的，第二次读取数据前，该数据被另一个事务修改提交了，两次结果不一样。采用可重复读的隔离级别可以防止这种情况。
3. 幻读：同一事务两次查询的多条数据结果不一样，第二次记录变多了。指的是该事务第一次查询了多条数据，第二次读取数据前，有一个事务插入了几条满足该事务的查询条件的数据，导致该事务第二次查询时，得到的数据变多。采用串行化的事务隔离级别可以防止这个情况。

### 数据库的事务隔离级别

* mysql：支持上面四种隔离级别，默认的为Repeatable read \(可重复读\)
* oracle：只支持Serializable \(串行化\)级别和Read committed \(读已提交\)这两种级别，其中默认的为Read committed级别



